static const char *purpose = "wrapper around system-installed compilers";
static const char *description =
    "This program is a wrapper around compilers that are already installed on the system. It ensures that the compiler has "
    "the expected version number and fails loudly if not.  This avoids problems that are encountered when one has a large "
    "collection of software generated by one compiler and then some system administrator or upgrade daemon installs a new "
    "compiler in its place.  When this happens, it is generally best to recompile said software in order to prevent subtle "
    "bugs that can appear when linking programs with parts generated by a variety of compilers.\n\n"

    "All command-line arguments are passed directly to the backend compiler except switches beginning with @s{spock-}, "
    "and these switches must appear before all other arguments.";

#include <Spock/Spock.C>

#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/trim.hpp>
#include <boost/filesystem.hpp>
#include <boost/foreach.hpp>
#include <boost/format.hpp>
#include <sys/wait.h>
#include <yaml-cpp/yaml.h>
#include <ctype.h>

using namespace Spock;
using namespace Sawyer::Message::Common;

namespace {

Sawyer::Message::Facility mlog;
bool showTriplet = false, showBaseExe = false, showBaseExeAndArgs = false;
boost::filesystem::path configFileOverride;

std::vector<std::string>
parseCommandLine(int argc, char *argv[]) {
    using namespace Sawyer::CommandLine;
    Parser p;
    p.errorStream(mlog[FATAL]);
    p.purpose(purpose);
    p.doc("Description", description);
    p.resetInclusionPrefixes();
    p.skippingUnknownSwitches(true);
    p.skippingNonSwitches(true);

    SwitchGroup sp("Spock-specific switches");

    sp.insert(Switch("spock-help")
              .action(showHelpAndExit(0))
              .doc("Show this documentation."));

    sp.insert(Switch("spock-version")
              .action(showVersionAndExit(Spock::VERSION, 0))
              .doc("Show the Spock version number, then exit."));

    sp.insert(Switch("spock-log")
              .action(configureDiagnostics("spock-log", Sawyer::Message::mfacilities))
              .argument("config")
              .whichValue(SAVE_ALL)
              .doc("Configure diagnostics.  Use \"@s{spock-log}=help\" and \"@s{spock-log}=list\" to get started."));

    sp.insert(Switch("spock-triplet")
              .intrinsicValue(true, showTriplet)
              .doc("Echo compiler information to standard output instead of running the compiler.  The information consists "
                   "of the following fields separated by colons: vendor name, language, and version."));

    sp.insert(Switch("spock-exe")
              .intrinsicValue(true, showBaseExe)
              .doc("Echo the full path of the real compiler without any switches, then exit. The output is printed in its "
                   "raw form without adding any shell quotes or backslashes."));

    sp.insert(Switch("spock-exe-full")
              .intrinsicValue(true, showBaseExeAndArgs)
              .doc("Echo the full path of the real compiler including switches, then exit. The output is escaped using "
                   "shell quotes and/or backslashes if necessary per component."));

    sp.insert(Switch("spock-config")
              .argument("filename", anyParser(configFileOverride))
              .doc("Name of configuration file. Normally the configuration file is named \"compiler.yaml\" and appears in "
                   "the same directory as this wrapper."));

    return p.with(sp).parse(argc, argv).apply().skippedArgs();
}

void
checkScalar(YAML::Node config, const std::string &fieldName, const boost::filesystem::path &configName) {
    if (!config[fieldName] || config[fieldName].Type() != YAML::NodeType::Scalar) {
        mlog[ERROR] <<"missing or incorrect type \"" <<fieldName <<" in " <<configName <<"\n";
        exit(1);
    }
}

// Find a compiler configuration file in the same directory as this executable.
YAML::Node
readConfigFile(const boost::filesystem::path &arg0) {
    boost::filesystem::path configName;
    if (configFileOverride.empty()) {
        configName = boost::filesystem::read_symlink("/proc/self/exe").parent_path() / "compiler.yaml";
    } else {
        configName = configFileOverride;
    }
    
    if (!boost::filesystem::exists(configName)) {
        mlog[ERROR] <<"missing compiler config file: " <<configName <<"\n";
        exit(1);
    }
    YAML::Node config = YAML::LoadFile(configName.string());
    checkScalar(config, "executable", configName);
    checkScalar(config, "language", configName);
    checkScalar(config, "vendor", configName);
    checkScalar(config, "version", configName);
    checkScalar(config, "version-output", configName);

    if (!config["flags"] || config["flags"].Type() != YAML::NodeType::Sequence) {
        mlog[ERROR] <<"missing or incorrect type \"flags\" in " <<configName <<"\n";
        exit(1);
    }
    
    return config;
}

// Validate that the executable still exists.
void
validateExecutable(YAML::Node config) {
    boost::filesystem::path exe = config["executable"].as<std::string>();
    if (!boost::filesystem::exists(exe)) {
        mlog[ERROR] <<"missing compiler executable " <<exe <<"\n";
        exit(1);
    }
}

// Allocate an argv array consisting of the executable name and arguments from the YAML file plus the extra arguments specified
// as the second argument to this function.
char**
buildArgv(YAML::Node config, const std::vector<std::string> &args) {
    size_t nargs = 1 /*path*/ + config["flags"].size() + args.size() + 1 /*nullptr*/;
    char **argv = new char*[nargs];
    int argc = 0;
    argv[argc++] = strdup(config["executable"].as<std::string>().c_str());
    for (size_t i=0; i<config["flags"].size(); ++i)
        argv[argc++] = strdup(config["flags"][i].as<std::string>().c_str());
    for (size_t i=0; i<args.size(); ++i)
        argv[argc++] = strdup(args[i].c_str());
    argv[argc] = NULL;
    return argv;
}

// Free resources used by an argv and return nullptr.
char**
deleteArgv(char **argv) {
    if (argv) {
        for (size_t i = 0; argv[i]; ++i) {
            if (argv[i])
                free(argv[i]);
        }
        free(argv);
    }
    return NULL;
}

// Runs the compiler with "--version" and checks that output against output that was generated previously and placed in the
// config file.
void
validateVersion(YAML::Node config) {
    boost::filesystem::path exe = config["executable"].as<std::string>();
    std::string compilerName = exe.filename().string();
    std::string childOutput;
    std::string oldOutput = config["version-output"].as<std::string>();
    char **argv = buildArgv(config, std::vector<std::string>(1, "--version"));
    if (mlog[DEBUG]) {
        mlog[DEBUG] <<"launching " <<argv[0] <<" with this argv:\n";
        for (int i=0; argv[i]; ++i)
            mlog[DEBUG] <<"  \"" <<argv[i] <<"\"\n";
    }

    int childToParent[2];
    pipe(childToParent);
    pid_t child = fork();
    if (-1 == child) {
        mlog[FATAL] <<"fork failed: " <<strerror(errno) <<"\n";
        exit(1);
    } else if (child) {
        // This is the parent
        argv = deleteArgv(argv);
        close(childToParent[1]);
        while (1) {
            char buf[4096];
            ssize_t nread = TEMP_FAILURE_RETRY(read(childToParent[0], buf, sizeof buf));
            if (-1 == nread) {
                mlog[FATAL] <<"read from child failed: " <<strerror(errno) <<"\n";
                break;
            } else if (0 == nread) {
                break;
            } else {
                childOutput += std::string(buf, buf+nread);
            }
        }
        close(childToParent[0]);
        int status = 0;
        waitpid(child, &status, 0);
        if (!WIFEXITED(status) || WEXITSTATUS(status)!=0) {
            mlog[ERROR] <<"compiler check did not exit with successful status\n";
            exit(1);
        }
    } else {
        // This is the child
        close(childToParent[0]);
        dup2(childToParent[1], 1);
        execv(exe.string().c_str(), argv);
        std::cerr <<"compiler " <<compilerName <<" failed to exec: " <<strerror(errno) <<"\n";
        exit(1);
    }

    // When comparing old and new lines, remove all white space first.
    std::string newStripped, oldStripped;
    BOOST_FOREACH (char ch, childOutput) {
        if (!isspace(ch))
            newStripped += ch;
    }
    BOOST_FOREACH (char ch, oldOutput) {
        if (!isspace(ch))
            oldStripped += ch;
    }
    if (newStripped != oldStripped) {
        mlog[ERROR] <<"compiler version info differs from original output\n";
        mlog[ERROR] <<"original output:\n";
        std::vector<std::string> lines;
        boost::split(lines, oldOutput, boost::is_any_of("\n"));
        BOOST_FOREACH (const std::string &line, lines) {
            if (!boost::trim_copy(line).empty())
                mlog[ERROR] <<"  |" <<line <<"\n";
        }

        mlog[ERROR] <<"current output:\n";
        lines.clear();
        boost::split(lines, childOutput, boost::is_any_of("\n"));
        BOOST_FOREACH (const std::string &line, lines) {
            if (!boost::trim_copy(line).empty())
                mlog[ERROR] <<"  |" <<line <<"\n";
        }
        exit(1);
    }
}

void
execCompiler(YAML::Node config, std::vector<std::string> &args) {
    char **argv = buildArgv(config, args);

    if (mlog[DEBUG]) {
        mlog[DEBUG] <<"launching " <<argv[0] <<" with this argv:\n";
        for (int i=0; argv[i]; ++i)
            mlog[DEBUG] <<"  \"" <<argv[i] <<"\"\n";
    }

    execv(argv[0], argv);
    mlog[ERROR] <<"failed to launch compiler: " <<argv[0] <<"\n";
    exit(1);
}

std::string
cEscape(char ch, char context) {
    std::string result;
    switch (ch) {
        case '\a':
            result += "\\a";
            break;
        case '\b':
            result += "\\b";
            break;
        case '\t':
            result += "\\t";
            break;
        case '\n':
            result += "\\n";
            break;
        case '\v':
            result += "\\v";
            break;
        case '\f':
            result += "\\f";
            break;
        case '\r':
            result += "\\r";
            break;
        case '\"':
            if ('"' == context) {
                result += "\\\"";
            } else {
                result += ch;
            }
            break;
        case '\'':
            if ('\'' == context) {
                result += "\\'";
            } else {
                result += ch;
            }
            break;
        case '\\':
            result += "\\\\";
            break;
        default:
            if (isprint(ch)) {
                result += ch;
            } else {
                result += (boost::format("\\%03o") % (unsigned)(unsigned char)ch).str();
            }
            break;
    }
    return result;
}

std::string
cEscape(const std::string &s, char context) {
    std::string result;
    BOOST_FOREACH (char ch, s)
        result += cEscape(ch, context);
    return result;
}

std::string
bourneEscape(const std::string &s) {
    if (s.empty())
        return "''";

    // The presence of non-printing characters or single quotes trumps all others and requires C-style quoting
    BOOST_FOREACH (char ch, s) {
        if (!::isprint(ch) || '\'' == ch)
            return "$'" + cEscape(s, '\'') + "'";
    }

    // If the string contains any shell meta characters or white space that must be quoted then single-quote the entire string
    // and escape backslashes.
    BOOST_FOREACH (char ch, s) {
        if (!::isalnum(ch) && !strchr("_-+./", ch))
            return "'" + boost::replace_all_copy(s, "\\", "\\\\") + "'";
    }

    // No quoting or escaping necessary
    return s;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // namespace

int
main(int argc, char *argv[]) {
    Spock::initialize(mlog);
    std::vector<std::string> args = parseCommandLine(argc, argv);
    YAML::Node config = readConfigFile(argv[0]);

    if (showTriplet) {
        std::cout <<config["vendor"].as<std::string>() <<":"
                  <<config["language"].as<std::string>() <<":"
                  <<config["version"].as<std::string>() <<"\n";
    } else if (showBaseExeAndArgs) {
        char **childArgs = buildArgv(config, std::vector<std::string>());
        for (size_t i = 0; childArgs[i]; ++i)
            std::cout <<(i?" ":"") <<bourneEscape(childArgs[i]);
        std::cout <<"\n";
        deleteArgv(childArgs);
        exit(0);
    } else if (showBaseExe) {
        std::cout <<config["executable"].as<std::string>() <<"\n";
        exit(0);
    }

    validateExecutable(config);
    validateVersion(config);

    if (!showTriplet && !showBaseExe)
        execCompiler(config, args);
}
